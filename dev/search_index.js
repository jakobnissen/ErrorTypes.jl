var documenterSearchIndex = {"docs":
[{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/#Types-and-how-to-construct-them","page":"Usage","title":"Types and how to construct them","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Option{T} encodes either the presence of a T or the absence of one. You should use this type to encode either the successful creation of T, or a failure that does not need any information to explain itself. Like its sibling Result, Option is a sum type from the pacage SumTypes.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"An Option contains two variants, None and Thing. Like other sum types, you should usually not construct an Option directly. Instead, the constructors for the types None and Thing creates an Option wrapping them. Similarly, you should not construct a None or Thing directly - these types are only useful as the content of an Option.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"You should construct an Option{T} wrapping a Thing with Thing(::T).\nYou can construct an Option{T} warpping a None object with ErrorTypes.None{Int}(). Normally, however, you should use the object none (singleton of None{Nothing}) and convert it to an Option{T}. See how in the section \"Basic usage\".","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Result{O, E} has the two variants Ok, representing the successful creation of an O, or else an E, representing some object carrying information about the error. You should use Result instead of Option when the error needs to be explained.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"You can construct Result objects by Ok{O, E}(::O) or Err{O, E}(::Err). However, normally, you can instead use the simpler constructors Ok(::O) and Err(::E). These constructors creates ResultConstructor objects, which can be converted to the correct Result types.","category":"page"},{"location":"usage/#Basic-usage","page":"Usage","title":"Basic usage","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Always typeassert any function that returns an error type. The whole point of ErrorTypes is to encode error states in return types, and be specific about these error states. While ErrorTypes will technically work fine without function annotation, I highly recommend annotating return types:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Yes (note none is automatically converted):","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"invert(x::Integer)::Option{Float64} = iszero(x) ? none : Thing(1/x)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"No:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"invert(x::Integer) = iszero(x) ? ErrorTypes.None{Float64}() : Thing(1/x)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Also, by annotating return functions, you can use the simpler constructors of error types:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"You can use none, which is automatically converted to Option containing a None.\nYou can use Err(x) and Ok(x) to create ResultConstructors, which are converted by the typeassert to the correct Result.","category":"page"},{"location":"usage/#Conversion","page":"Usage","title":"Conversion","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Apart from the two special cases above: The conversion of none (of type None) to Option, and Err(x) and Ok(x) (of type ResultConstructor) to Result, error types can only convert to each other in certain circumstances. This is intentional, because type conversions is a major source of mistakes.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"An object of type Option and Result can be converted to its own type.\nAn Option{T} containing a Thing can be converted to an Option{T2}, if T <: T2. You intentionally cannot convert e.g. an Option{Int} to an Option{UInt}.\nA Result{O, E} can be converted to a Result{O2, E2} if O <: O2 and E <: E2.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"It is intentionally NOT possible to e.g. convert a Result{Int, String} containing an Ok to a Result{Int, Int}, even if the Ok value contains an Int which is allowed in both of the Result types. The reason for this is that if it was allowed, whether or not conversions threw errors would depend on the value of an error type, not the type. The idea behind this package is to present edge cases as types, not values.","category":"page"},{"location":"usage/#@?","page":"Usage","title":"@?","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"If you make an entire codebase of functions returning Results and Options, it can get bothersome to constantly check if function calls contain error values and propagate those error values. To make this process easier, use the macro @?, which automatically propagates any error values. If this is applied to some expression x evaluating to a Result or Option containing an error value, the macro will evaluate to something equivalent to return Err(unwrap_err(x)) or return none, respectively. If it contains a result value, the macro is evaluated to the equivalent of unwrap(x).","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"For example, suppose you want to implement a safe version of the harmonic mean function, which in turn uses a safe version of div:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"safe_div(a::Integer, b::Float64)::Option{Float64} = iszero(b) ? none : Thing(a/b)\n\nfunction harmonic_mean(v::AbstractArray{<:Integer})::Option{Float64}\n    sm = 0.0\n    for i in v\n        invi = safe_div(1, i)\n        is_none(invi) && return none\n        sm += unwrap(invi)\n    end\n    res = safe_div(length(v), sm)\n    is_none(res) && return none\n    return Thing(unwrap(res))\nend","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"In this function, we constantly have to check whether safe_div returned the error value, and return that from the outer function in that case. That can be more concisely written as:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"function harmonic_mean(v::AbstractArray{<:Integer})::Option{Float64}\n    sm = 0.0\n    for i in v\n        sm += @? safe_div(1, i)\n    end\n    Thing(@? safe_div(length(v), sm))\nend","category":"page"},{"location":"usage/#Reference","page":"Usage","title":"Reference","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Modules = [ErrorTypes]","category":"page"},{"location":"usage/#ErrorTypes.Err-Tuple{Any}","page":"Usage","title":"ErrorTypes.Err","text":"Err\n\nThe error state of a Result{O, E}, carrying an object of type E. For convenience, Err(x) creates a dummy value that can be converted to the appropriate Result type.\n\n\n\n\n\n","category":"method"},{"location":"usage/#ErrorTypes.None","page":"Usage","title":"ErrorTypes.None","text":"None{T}\n\nThe variant of Option signifying absence of a value of type T. The singleton none is the instance of None{Nothing} (NOT an Option), and can be freely converted to any Option value containing a None.\n\n\n\n\n\n","category":"type"},{"location":"usage/#ErrorTypes.Ok-Tuple{Any}","page":"Usage","title":"ErrorTypes.Ok","text":"Ok\n\nThe success state of a Result{O, E}, carrying an object of type O. For convenience, Ok(x) creates a dummy value that can be converted to the appropriate Result type.\n\n\n\n\n\n","category":"method"},{"location":"usage/#ErrorTypes.Option","page":"Usage","title":"ErrorTypes.Option","text":"Option{T}\n\nA sum type of either Thing{T} or None. Used instead of Result as return value of functions whose error state need not carry any information.\n\n\n\n\n\n","category":"type"},{"location":"usage/#ErrorTypes.Result","page":"Usage","title":"ErrorTypes.Result","text":"Result{O, E}\n\nA sum type of either Ok{O} or Err{E}. Used as return value of functions that can error with an informative error object of type E.\n\n\n\n\n\n","category":"type"},{"location":"usage/#ErrorTypes.Thing-Tuple{T} where T","page":"Usage","title":"ErrorTypes.Thing","text":"Thing(x::T)\n\nConstruct a Thing{T}(x), variant of Option signifying the presence of a value x.\n\n\n\n\n\n","category":"method"},{"location":"usage/#ErrorTypes.and_then-Tuple{Any,Option}","page":"Usage","title":"ErrorTypes.and_then","text":"and_then(f, x::Union{Option, Result})\n\nIf x is an error value, return x. Else, apply f to the contained value and return it wrapped as the same type as x.\n\n\n\n\n\n","category":"method"},{"location":"usage/#ErrorTypes.expect","page":"Usage","title":"ErrorTypes.expect","text":"expect(x::Union{Result, Option}, s::AbstractString)\n\nIf x is of the associated error type, error with message s. Else, return the contained result type.\n\n\n\n\n\n","category":"function"},{"location":"usage/#ErrorTypes.expect_err-Tuple{Result,AbstractString}","page":"Usage","title":"ErrorTypes.expect_err","text":"expect_err(x::Result, s::AbstractString)\n\nIf x contains an Err, return the content of the Err. Else, throw an error with message s.\n\n\n\n\n\n","category":"method"},{"location":"usage/#ErrorTypes.expect_none-Tuple{Option,AbstractString}","page":"Usage","title":"ErrorTypes.expect_none","text":"expect_none(x::Option, s::AbstractString)\n\nIf x contains a None, return nothing. Else, throw an error with message s.\n\n\n\n\n\n","category":"method"},{"location":"usage/#ErrorTypes.flatten-Union{Tuple{Option{Option{T}}}, Tuple{T}} where T","page":"Usage","title":"ErrorTypes.flatten","text":"flatten(x::Option{Option{T}})\n\nConvert an Option{Option{T}} to an Option{T}.\n\nExamples\n\njulia> flatten(Thing(Thing(\"x\")))\nOption{String}: Thing(\"x\")\n\njulia> flatten(Thing(None{Int}()))\nOption{Int64}: None()\n\n\n\n\n\n","category":"method"},{"location":"usage/#ErrorTypes.unwrap","page":"Usage","title":"ErrorTypes.unwrap","text":"unwrap(x::Union{Result, Option})\n\nIf x is of the associated error type, throw an error. Else, return the contained result type.\n\n\n\n\n\n","category":"function"},{"location":"usage/#ErrorTypes.unwrap_err-Tuple{Result}","page":"Usage","title":"ErrorTypes.unwrap_err","text":"unwrap_err(x::Result)\n\nIf x contains an Err, return the content of the Err. Else, throw an error.\n\n\n\n\n\n","category":"method"},{"location":"usage/#ErrorTypes.unwrap_none-Tuple{Option}","page":"Usage","title":"ErrorTypes.unwrap_none","text":"unwrap_none(x::Option)\n\nIf x contains a None, return nothing. Else, throw an error.\n\n\n\n\n\n","category":"method"},{"location":"usage/#ErrorTypes.unwrap_or-Tuple{Option,Any}","page":"Usage","title":"ErrorTypes.unwrap_or","text":"unwrap_or(x::Union{Option, Result}, v)\n\nIf x is an error value, return v. Else, unwrap x and return its content.\n\n\n\n\n\n","category":"method"},{"location":"usage/#ErrorTypes.@?-Tuple{Any}","page":"Usage","title":"ErrorTypes.@?","text":"@?(expr)\n\nPropagate a Result or Option error value to the outer function. Evaluate expr, which should return a Result or Option. If it contains a result value x, evaluate to the unwrapped value x. Else, evaluates to return none for Option and return Err(x) for Result.\n\nExample\n\njulia> (f(x::Option{T})::Option{T}) where T = Thing(@?(x) + one(T))\n\njulia> f(Thing(1.0)), f(None{Int}())\n(Option{Float64}: Thing(2.0), Option{Int64}: None())\n\n\n\n\n\n","category":"macro"},{"location":"usage/#ErrorTypes.@unwrap_or-Tuple{Any,Any}","page":"Usage","title":"ErrorTypes.@unwrap_or","text":"@unwrap_or(expr, exec)\n\nEvaluate expr to a Result or Option. If expr is a error value, evaluate exec and return that. Else, return the wrapped value in expr.\n\nExamples\n\njulia> safe_inv(x)::Option{Float64} = iszero(x) ? none : Thing(1/x);\n\njulia> function skip_inv_sum(it)\n    sum = 0.0\n    for i in it\n        sum += @unwrap_or safe_inv(i) continue\n    end\n    sum\nend;\n\njulia> skip_inv_sum([2,1,0,1,2])\n3.0\n\n\n\n\n\n","category":"macro"},{"location":"#ErrorTypes.jl","page":"Home","title":"ErrorTypes.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ErrorTypes provides an easy way to efficiently encode error states in return types. Its types are modelled after Rust's Option and Result.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Example","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ErrorTypes\n\nfunction safe_maximum(x::AbstractArray)::Option{eltype(x)}\n    isempty(x) && return none # return an Option with a None inside\n    return Thing(maximum(x)) # return an Option with a Thing inside\nend\n\nfunction using_safe_maximum(x)\n    maybe_val = safe_maximum(x)\n    println(\"Maximum is $(unwrap_or(maybe_val, \"[ERROR - EMPTY ARRAY]\"))\")\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"See also: Usage","category":"page"},{"location":"","page":"Home","title":"Home","text":"Advantages","category":"page"},{"location":"","page":"Home","title":"Home","text":"Zero-cost: In fully type-stable code, error handling using ErrorTypes is as fast as a manual check for the edge case, and significantly faster than exception handling.\nIncreased safety: ErrorTypes is designed to make you not guess. By making edge cases explicit, your code will be more reliable for yourself and for others.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See also: Why use ErrorTypes?","category":"page"},{"location":"","page":"Home","title":"Home","text":"Comparisons to other packages","category":"page"},{"location":"","page":"Home","title":"Home","text":"The idea behind this package is well known and used in other languages, e.g. Rust and the functional languages (Clojure, Haskell etc). It is also implemented in the Julia packages Expect and ResultTypes, and to some extend MLStyle. Compared to these packages, ErrorTypes offer:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Efficiency: All ErrorTypes methods and types should be maximally efficient. For example, an Option{T} is as lightweight as a Union{T, Nothing}, and manipulation of the Option is as efficient as a === check against nothing.\nIncreased comfort. The main disadvantage of using these packages are the increased friction in development. ErrorTypes provides more quality-of-life functionality for working with error types than Expect and ResultTypes, for example the simple Option type.\nFlexibility. Whereas Expect and ResultTypes require your error state to be encoded in an Exception object, ErrorTypes allow you to store it how you want. Want to store error codes as a Bool? Sure, why not.\nStrictness: ErrorTypes tries hard to not guess what you're doing. Error types with concrete values cannot be converted to another error type, and non-error types are never implicitly converted to error types. Generally, ErrorTypes tries to minimize room for error.","category":"page"},{"location":"motivation/#Why-use-ErrorTypes?","page":"Why use ErrorTypes?","title":"Why use ErrorTypes?","text":"","category":"section"},{"location":"motivation/","page":"Why use ErrorTypes?","title":"Why use ErrorTypes?","text":"In short, ErrorTypes improves the safety of your error-handling code by reducing the opportunities for human error.","category":"page"},{"location":"motivation/","page":"Why use ErrorTypes?","title":"Why use ErrorTypes?","text":"Some people think the source of programming bug are programs who misbehave by not computing what they are supposed to. This is false. Bugs arise from human failure. We humans fail to understand the programs we write. We forget the edge cases We create leaky abstractions. We don't document thoroughly.","category":"page"},{"location":"motivation/","page":"Why use ErrorTypes?","title":"Why use ErrorTypes?","text":"If we want better programs, it is pointless to wait around for better humans to arrive. We can't excuse the existence of bugs with the existence human fallibility, because we will never get rid of that. Instead, we must design systems to contain and mitigate human error. Programming languages are such systems.","category":"page"},{"location":"motivation/","page":"Why use ErrorTypes?","title":"Why use ErrorTypes?","text":"One source of such error is fallible functions. Some functions are natually fallible. Consider, for example, the maximum function from Julia's Base. This function will fail on empty collections. With an edge case like this, some human is bound to forget it at some point, and produce fragile software as a result. The behaviour of maximum is a bug waiting to happen.","category":"page"},{"location":"motivation/","page":"Why use ErrorTypes?","title":"Why use ErrorTypes?","text":"However, because we know there is a potential bug hiding here, we have the ability to act. We can use our programming language to force us to remember the edge case. We can, for example, encode the edge case into the type system such that any code that forgets the edge case simply won't compile.","category":"page"},{"location":"motivation/#An-illustrative-example","page":"Why use ErrorTypes?","title":"An illustrative example","text":"","category":"section"},{"location":"motivation/","page":"Why use ErrorTypes?","title":"Why use ErrorTypes?","text":"Suppose you're building an important package that includes some text processing. At some point, you need a function that gets the length of the first word (in bytes) of some text. So, you write up the following:","category":"page"},{"location":"motivation/","page":"Why use ErrorTypes?","title":"Why use ErrorTypes?","text":"function first_word_bytes(s::Union{String, SubString{String}})\n    findfirst(isspace, lstrip(s)) - 1\nend","category":"page"},{"location":"motivation/","page":"Why use ErrorTypes?","title":"Why use ErrorTypes?","text":"Easy, fast, flexible, relatively generic. You also write a couple of tests to handle the edge cases:","category":"page"},{"location":"motivation/","page":"Why use ErrorTypes?","title":"Why use ErrorTypes?","text":"@test first_word_bytes(\"Lorem ipsum\") == 5\n@test first_word_bytes(\" dolor sit amet\") == 5 # leading whitespace\n@test first_word_bytes(\"Rødgrød med fløde\") == 9 # Unicode","category":"page"},{"location":"motivation/","page":"Why use ErrorTypes?","title":"Why use ErrorTypes?","text":"All tests pass, and you push to production. But alas! Your code has a horrible bug that causes your production server to crash! See, you forgot an edge case:","category":"page"},{"location":"motivation/","page":"Why use ErrorTypes?","title":"Why use ErrorTypes?","text":"julia> first_word_bytes(\"boo!\")\nERROR: MethodError: no method matching -(::Nothing, ::Int64)","category":"page"},{"location":"motivation/","page":"Why use ErrorTypes?","title":"Why use ErrorTypes?","text":"The infuriating part is that the Julia compiler is in on the plot against you: It knew that findfirst returned a Union{Int, Nothing}, not an Int as you assumed it did. It just decided to not share that information, leading you into a hidden trap.","category":"page"},{"location":"motivation/","page":"Why use ErrorTypes?","title":"Why use ErrorTypes?","text":"We can do better. With this package, you can specify the return type of any function that can possibly fail. Here, we will encode it as an Option{Int}:","category":"page"},{"location":"motivation/","page":"Why use ErrorTypes?","title":"Why use ErrorTypes?","text":"using ErrorTypes\n\nfunction safer_findfirst(f, x)::Option{eltype(keys(x))}\n    for (k, v) in pairs(x)\n        f(v) && return Thing(k) # thing: value\n    end\n    none # none: absence of value\nend","category":"page"},{"location":"motivation/","page":"Why use ErrorTypes?","title":"Why use ErrorTypes?","text":"Now, if you forget that safer_findfirst can error, and mistakenly assume that it always return an Int, your first_word_bytes will error in all cases, because almost no operation are permitted on Option objects.","category":"page"},{"location":"motivation/#Why-would-you-NOT-use-ErrorTypes?","page":"Why use ErrorTypes?","title":"Why would you NOT use ErrorTypes?","text":"","category":"section"},{"location":"motivation/","page":"Why use ErrorTypes?","title":"Why use ErrorTypes?","text":"Using ErrorTypes, or packages like it, provides a small but constant friction in your code. It will increase the burden of maintenance.","category":"page"},{"location":"motivation/","page":"Why use ErrorTypes?","title":"Why use ErrorTypes?","text":"You will be constantly wrapping and unwrapping return values, and you now have to annotate function's return values. Refactoring code becomes a larger job, because these large, clunky type signatures all have to be changed. You will make mistakes with your return signatures and type conversions, which will slow down deveopment. Furthermore, you (intentionally) place retrictions on the input and output types of your functions, which, depending on the function's design, can limit its uses.","category":"page"},{"location":"motivation/","page":"Why use ErrorTypes?","title":"Why use ErrorTypes?","text":"So, use of this package comes down to how much developing time you are willing to pay for building more reliable software. Sometimes, it's not worth it.","category":"page"}]
}
