<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Usage · ErrorTypes.jl</title><meta name="title" content="Usage · ErrorTypes.jl"/><meta property="og:title" content="Usage · ErrorTypes.jl"/><meta property="twitter:title" content="Usage · ErrorTypes.jl"/><meta name="description" content="Documentation for ErrorTypes.jl."/><meta property="og:description" content="Documentation for ErrorTypes.jl."/><meta property="twitter:description" content="Documentation for ErrorTypes.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ErrorTypes.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Usage</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Reference"><span>Reference</span></a></li></ul></li><li><a class="tocitem" href="../motivation/">Why use ErrorTypes?</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Usage</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Usage</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jakobnissen/ErrorTypes.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/master/docs/src/usage.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h1><h3 id="The-Result-type"><a class="docs-heading-anchor" href="#The-Result-type">The Result type</a><a id="The-Result-type-1"></a><a class="docs-heading-anchor-permalink" href="#The-Result-type" title="Permalink"></a></h3><p>Fundamentally, we have <code>Result{T, E}</code>. This type <em>contains</em> either a successful value of type <code>T</code> or an error of type <code>E</code>. For example, a function returning either a string or a 32-bit integer error code could return a <code>Result{String, Int32}</code>.</p><p>You can construct it like this:</p><pre><code class="language-julia-repl hljs">julia&gt; Result{String, Int}(Ok(&quot;Nothing went wrong&quot;))
Result{String, Int64}(Ok(&quot;Nothing went wrong&quot;))</code></pre><p>Thus, a <code>Result{T, E}</code> represents <em>either</em> a successful creation of a <code>T</code> or an error of type <code>E</code>.</p><h4 id="Option"><a class="docs-heading-anchor" href="#Option">Option</a><a id="Option-1"></a><a class="docs-heading-anchor-permalink" href="#Option" title="Permalink"></a></h4><p><code>Option{T}</code> is an alias for <code>Result{T, Nothing}</code>, and is easier to work with fully specifying the parameters of <code>Result</code>s. <code>Option</code> is useful when the error state do not need to store any information besides the fact than an error occurred. <code>Option</code>s can be conventiently created with two helper functions <code>some</code> and <code>none</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; some(1) === Result{typeof(1), Nothing}(Ok(1))
true

julia&gt; none(Int) === Result{Int, Nothing}(Err(nothing))
true</code></pre><p>If you want an abstractly parameterized <code>Option</code>, you can construct it directly like this:</p><pre><code class="language-julia-repl hljs">julia&gt; Option{Integer}(some(1))
Option{Integer}(some(1))</code></pre><h4 id="ResultConstructor"><a class="docs-heading-anchor" href="#ResultConstructor">ResultConstructor</a><a id="ResultConstructor-1"></a><a class="docs-heading-anchor-permalink" href="#ResultConstructor" title="Permalink"></a></h4><p>Internally, <code>Result{T, E}</code> contains a field typed <code>Union{Ok{T}, Err{E}}.</code> The types <code>Ok</code> and <code>Err</code> are not supposed to be instantiated directly (and indeed, cannot be easily instantiated).</p><p>Calling <code>Ok(x)</code> or <code>Err(x)</code> instead creates an instance of the non-exported type <code>ResultConstructor</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; Err(1)
ErrorTypes.ResultConstructor{Int64, Err}(1)

julia&gt; Ok(1)
ErrorTypes.ResultConstructor{Int64, Ok}(1)</code></pre><p>The only purpose of <code>ResultConstructor</code> is to more easily create <code>Result</code>s with the correct parameters, and to allow conversions of carefully selected types, read on to learn how. The user does not need to think much about <code>ResultConstructor</code>, but if <code>ErrorTypes</code> is abused, this type can show up in the stacktraces.</p><p><code>none</code> by itself is a constant for <code>ErrorTypes.ResultConstructor{Nothing, Err}(nothing)</code> - we will come back to why this is particularly convenient.</p><h3 id="Basic-usage"><a class="docs-heading-anchor" href="#Basic-usage">Basic usage</a><a id="Basic-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-usage" title="Permalink"></a></h3><p>Always typeassert any function that returns an error type. The whole point of ErrorTypes is to encode error states in return types, and be specific about these error states. While ErrorTypes will <em>technically</em> work fine without function annotations, it makes everything easier, and I highly recommend annotating return types:</p><p>Do this:</p><pre><code class="language-julia hljs">invert(x::Integer)::Option{Float64} = iszero(x) ? none : some(1/x)</code></pre><p>And not this:</p><pre><code class="language-julia hljs">invert(x::Integer) = iszero(x) ? none(Float64) : some(1/x)</code></pre><p>When annotating a function with a return type <code>T</code>, the return value gets converted at the end with an explicit <code>convert(T, return_value)</code>.</p><p>In the function in this example, the function can return <code>none</code>, which was a generic instance of <code>ResultConstructor</code>. When that happens, <code>none</code> is automatically converted to the correct value, in this case <code>none(Float64)</code>. Similarly, one can also use a typeassert to ease in the construction of <code>Result</code> return type:</p><pre><code class="language-julia hljs">function get_length(x)::Result{Int, Base.IteratorSize}
    isz = Base.IteratorSize(x)
    if isa(isz, Base.HasShape) || isa(isz, Base.HasLength)
        return Ok(Int(length(x)))
    else
        return Err(isz)
    end
end</code></pre><p>In the above example example, <code>Ok(Int(length(x))</code> returns a <code>ResultConstructor{Int, Ok}</code>, which can be converted to the target <code>Result{Int, Base.IteratorSize}</code>. Similarly, the <code>Err(isz)</code> creates a <code>ResultConstructor{Base.IteratorSize, Err}</code>, which can likewise be converted.</p><p>In most cases therefore, you never have to constuct an <code>Option</code> or <code>Result</code> directly. Instead, use a typeassert and return <code>some(x)</code> or <code>none</code> to return an <code>Option</code>, and return <code>Ok(x)</code> or <code>Err(x)</code> to return a <code>Result</code>.</p><h3 id="Conversion-rules"><a class="docs-heading-anchor" href="#Conversion-rules">Conversion rules</a><a id="Conversion-rules-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion-rules" title="Permalink"></a></h3><p>Error types can only convert to each other in certain circumstances. This is intentional, because type conversion is a major source of mistakes.</p><ul><li>A <code>Result{T, E}</code> can be converted to <code>Result{T2, E2}</code> iff <code>T &lt;: T2</code> and <code>E &lt;: E2</code>, i.e. you can always convert to a &quot;larger&quot; Result type or to its own type.</li><li>A <code>ResultConstructor{T, Ok}</code> can be converted to <code>Result{T2, E}</code> if <code>T &lt;: T2</code>.</li><li>A <code>ResultConstructor{E, Err}</code> can be converted to <code>Result{T, E2}</code> if <code>E &lt;: E2</code>.</li></ul><p>The first rule merely state that a <code>Result</code> can be converted to another <code>Result</code> if both the success parameter (<code>Ok{T}</code>) and the error parameter (<code>Err{E}</code>) error types are a supertype. It is intentionally NOT possible to e.g. convert a <code>Result{Int, String}</code> containing an <code>Ok</code> to a <code>Result{Int, Int}</code>, even if the <code>Ok</code> value contains an <code>Int</code> which is allowed in both of the <code>Result</code> types. The reason for this is that if it was allowed, whether or not conversions threw errors would depend on the <em>value</em> of an error type, not the type. This type-unstable behaviour would defeat idea behind this package, namely to present edge cases as types, not values.</p><p>The next two rules state that <code>ResultConstructors</code> have relaxed this requirement, and so a <code>ResultConstructors</code> constructed from an <code>Ok</code> or <code>Err</code> can be converted if only the <code>Ok{T}</code> or the <code>Err{E}</code> parameter, respectively, is a supertype, not necessarily both parameters. This is what enables use of <code>Ok(x)</code>, <code>Err(x)</code> and <code>none</code> as return values when the function is annotated with return type.</p><p>There is one last type, <code>ResultConstructor{T, Union{}}</code>, which is even more flexible in how it converts. This is created by the <code>@?</code> macro, discussed next.</p><h3 id="@?"><a class="docs-heading-anchor" href="#@?">@?</a><a id="@?-1"></a><a class="docs-heading-anchor-permalink" href="#@?" title="Permalink"></a></h3><p>If you make an entire codebase of functions returning <code>Result</code>s, it can get bothersome to constantly check if function calls contain error values and propagate those error values to their callers. To make this process easier, use the macro <code>@?</code>, which automatically propagates any error values. If this is applied to some expression <code>x</code> evaluating to a <code>Result</code> containing a success value (i.e. <code>Ok{T}</code>), the macro will evaluate to the inner wrapped value:</p><pre><code class="nohighlight hljs">julia&gt; @? Result{String, Int}(Ok(&quot;foo&quot;))
&quot;foo&quot;</code></pre><p>However, if <code>x</code> evaluates to an error value <code>Err{E}</code>, the macro creates a <code>ResultConstructor{E, Union{}}</code>, let&#39;s call it <code>y</code>, and evaluates to <code>return y</code>. In this manner, the macro means &quot;unwrap the value if possible, and else immediately return it to the outer function&quot;. <code>ResultConstructor{E, Union{}}</code> are even more flexible in what they can be converted to: They can convert to any <code>Option</code> type, or any <code>Result{T, E2}</code> where <code>E &lt;: E2</code>. This allows you to propagate errors from functions returning <code>Result</code> to those returning <code>Option</code>.</p><p>Let&#39;s see it in action. Suppose you want to implement a safe version of the harmonic mean function, which in turn uses a safe version of <code>div</code>:</p><pre><code class="language-julia hljs">safe_div(a::Integer, b::Real)::Option{Float64} = iszero(b) ? none : some(a/b)

function harmonic_mean(v::AbstractArray{&lt;:Integer})::Option{Float64}
    sm = 0.0
    for i in v
        invi = safe_div(1, i)
        is_error(invi) &amp;&amp; return none
        sm += unwrap(invi)
    end
    res = safe_div(length(v), sm)
    is_error(res) &amp;&amp; return none
    return some(unwrap(res))
end</code></pre><p>In this function, we constantly have to check whether <code>safe_div</code> returned the error value, and return that from the outer function in that case. That can be more concisely written as:</p><pre><code class="language-julia hljs">function harmonic_mean(v::AbstractArray{&lt;:Integer})::Option{Float64}
    sm = 0.0
    for i in v
        sm += @? safe_div(1, i)
    end
    some(@? safe_div(length(v), sm))
end</code></pre><p>In case any of the calls to <code>safe_div</code> yields a <code>none(Float64)</code>, the <code>@?</code> macro evaluates to code equivalent to <code>return ResultConstructor{Nothing, Union{}}(nothing)</code>. This value is then converted by the typeassert in the outer function to <code>none(Float64)</code></p><h3 id="When-to-use-an-error-type-vs-throw-an-error"><a class="docs-heading-anchor" href="#When-to-use-an-error-type-vs-throw-an-error">When to use an error type vs throw an error</a><a id="When-to-use-an-error-type-vs-throw-an-error-1"></a><a class="docs-heading-anchor-permalink" href="#When-to-use-an-error-type-vs-throw-an-error" title="Permalink"></a></h3><p>The error handling mechanism provided by ErrorTypes is a distinct method from throwing and catching errors. None is superior to the other in all circumstances.</p><p>The handling provided by ErrorTypes is faster, safer, and more explicit. For <em>most</em> functions, you can use ErrorTypes. However, you can&#39;t <em>only</em> rely on it. Imagine a function <code>A</code> returning <code>Option{T1}</code>. <code>A</code> is called from function <code>B</code>, which can itself fail and returns an <code>Option{T2}</code>. However, now there are two distinct error states: Failure in <code>A</code> and failure in <code>B</code>. So what should <code>B</code> return? <code>Result{T2, Enum{E1, E2}}</code>, for some <code>Enum</code> type? But then, what about functions calling <code>B</code>? Where does it end?</p><p>In general, it&#39;s un-idiomatic to &quot;accumulate&quot; error states like this. You should handle an error state when it appears, and usually not return it far back the call chain.</p><p>More importantly, you should distinguish between <em>recoverable</em> and <em>unrecoverable</em> error states. The unrecoverable are unexpected, and reveals that the program went wrong somehow. If the program went somewhere it shouldn&#39;t be, it&#39;s best to abort the program and show the stack trace, so you can debug it - here, an ordinary exception is better. If the errors are known to be possible beforehand, using ErrorTypes is better. For example, a program may use exceptions when encountering errors when parsing &quot;internal&quot; machine-generated files, which are <em>supposed</em> to be of a certain format, and use error types when parsing user input, which must always be expected to be possibly fallible.</p><p>Because error types are so easily converted to exceptions (using <code>unwrap</code> and <code>expect</code>), internal library functions should preferably use error types.</p><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ErrorTypes.none" href="#ErrorTypes.none"><code>ErrorTypes.none</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">none</code></pre><p>Singleton instance of <code>ResultConstructor{Nothing, Err}(nothing)</code>. This value is useful because it can be <code>convert</code>ed to any <code>Option{T}</code>, giving the error value.</p><p>See also: <a href="#Option"><code>Option</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f(x)::Option{Float64} = iszero(x) ? none : 1 / x;

julia&gt; f(0)
none(Float64)

julia&gt; struct MaybeInt32 x::Option{Int32} end;

julia&gt; MaybeInt32(none)
MaybeInt32(none(Int32))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/9a86cd5434a650320b5700d748826903eb6e7dac/src/ErrorTypes.jl#L206-L227">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ErrorTypes.none-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#ErrorTypes.none-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>ErrorTypes.none</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">none(::Type)::Option{T}</code></pre><p>Construct the error value of <code>Option{T}</code>.</p><p>See also: <a href="#Option"><code>Option</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; none(String) === Option{String}(Err(nothing))
true

julia&gt; none(Char) isa Option{Char}
true

julia&gt; is_error(none(Char))
true

julia&gt; convert(Option{Vector}, none) === none(Vector)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/9a86cd5434a650320b5700d748826903eb6e7dac/src/ErrorTypes.jl#L230-L251">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ErrorTypes.Err" href="#ErrorTypes.Err"><code>ErrorTypes.Err</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Err</code></pre><p>The error state of a <code>Result{O, E}</code>, carrying an object of type <code>E</code>. For convenience, <code>Err(x)</code> creates a dummy value that can be converted to the appropriate <code>Result type</code>.</p><p>For a more detailed description, see: <a href="#ErrorTypes.Ok"><code>Ok</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/9a86cd5434a650320b5700d748826903eb6e7dac/src/ErrorTypes.jl#L35-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ErrorTypes.Ok" href="#ErrorTypes.Ok"><code>ErrorTypes.Ok</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Ok{T}</code></pre><p>The success state of a <code>Result{T, E}</code>, carrying an object of type <code>T</code>. For convenience, <code>Ok(x)</code> creates a dummy value that can be converted to the appropriate <code>Result type</code>.</p><p>Instances of <code>Ok</code> and its mirror image <code>Err</code> cannot be directly constructed.</p><p>See also: <a href="#ErrorTypes.Err"><code>Err</code></a></p><pre><code class="language-julia-repl hljs">julia&gt; function reciprocal(x::Int)::Result{Float64, String}
           iszero(x) &amp;&amp; return Err(&quot;Division by zero&quot;)
           Ok(1 / x)
       end;

julia&gt; reciprocal(4)
Result{Float64, String}(Ok(0.25))

julia&gt; reciprocal(0)
Result{Float64, String}(Err(&quot;Division by zero&quot;))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/9a86cd5434a650320b5700d748826903eb6e7dac/src/ErrorTypes.jl#L6-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ErrorTypes.Option" href="#ErrorTypes.Option"><code>ErrorTypes.Option</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Option{T}</code></pre><p>Alias for <code>Result{T, Nothing}</code>. Useful when the error type of a <code>Result</code> need not store any information. Construct value instances with <code>some(x)</code> and error instances with <code>none(::Type)</code>.</p><p>See also: <a href="#ErrorTypes.Result"><code>Result</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; some(4) isa Option{Int}
true

julia&gt; is_error(some(4))
false

julia&gt; none(String) isa Option{String} &amp;&amp; is_error(none(String))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/9a86cd5434a650320b5700d748826903eb6e7dac/src/ErrorTypes.jl#L160-L180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ErrorTypes.Result" href="#ErrorTypes.Result"><code>ErrorTypes.Result</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Result{O, E}</code></pre><p>A sum type of either <code>Ok{O}</code> or <code>Err{E}</code>. Used as return value of functions that can error with an informative error object of type <code>E</code>.</p><p>Results are normally constructed implicitly, through <code>convert</code>ing <code>ResultConstructor</code> using <code>Ok</code> or <code>Err</code>, such as in:</p><pre><code class="language-julia-repl hljs">julia&gt; x::Result{Int, String} = Err(&quot;Oh my!&quot;);

julia&gt; x
Result{Int64, String}(Err(&quot;Oh my!&quot;))</code></pre><p>See also: <a href="#Option"><code>Option</code></a>, <a href="#ErrorTypes.Ok"><code>Ok</code></a>, <a href="#ErrorTypes.Err"><code>Err</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Result{UInt8, UInt32}(Ok(0x03)) # manual constructor
Result{UInt8, UInt32}(Ok(0x03))

julia&gt; make_err()::Result{Vector{Int}, String} = Err(&quot;error!&quot;);

julia&gt; make_err()
Result{Vector{Int64}, String}(Err(&quot;error!&quot;))

julia&gt; is_error(make_err())
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/9a86cd5434a650320b5700d748826903eb6e7dac/src/ErrorTypes.jl#L95-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ErrorTypes.ResultConstructor" href="#ErrorTypes.ResultConstructor"><code>ErrorTypes.ResultConstructor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Err(x::T)::ResultConstructor{T, Err}
Ok(x::T)::ResultConstrutor{T, Ok}
none::ResultConstructor{Nothing, Err}
(@? x::Result{T,E}(Err{E}))::ResultConstructor{T, Union{}}</code></pre><p>Instances of <code>ResultConstructor</code> are temporary values, which are constructed only to be immediately <code>convert</code>ed to <code>Result</code>. Proper use of <code>ErrorTypes.jl</code> should not result in <code>ResultConstructors</code> leaking out of functions.</p><p>The constructors <code>Ok</code> and <code>Err</code> return <code>ResultConstructor</code>, and the constant <code>none</code> is the <code>ResultConstructor</code> for <code>Option</code>.</p><p>Typical use of <code>ResultConstructor</code> is to construct it immediately before returning it. If the function&#39;s return type is annotated to <code>Result</code>, the value will be <code>converted</code>.</p><p><strong>Examples:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sat_sub(x::UInt8)::Result{UInt8, String} = iszero(x) ? Err(&quot;Overflow&quot;) : Ok(x - 0x01);

julia&gt; sat_sub(0x00)
Result{UInt8, String}(Err(&quot;Overflow&quot;))

julia&gt; sat_sub(0x01)
Result{UInt8, String}(Ok(0x00))

julia&gt; sat_sub(x::UInt8)::Option{UInt8} = iszero(x) ? none : Ok(x - 0x01);

julia&gt; sat_sub(0x00)
none(UInt8)

julia&gt; sat_sub(0x01)
some(0x00)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/9a86cd5434a650320b5700d748826903eb6e7dac/src/ErrorTypes.jl#L49-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ErrorTypes.and_then-Union{Tuple{E}, Tuple{O}, Tuple{T}, Tuple{Any, Type{T}, Result{O, E}}} where {T, O, E}" href="#ErrorTypes.and_then-Union{Tuple{E}, Tuple{O}, Tuple{T}, Tuple{Any, Type{T}, Result{O, E}}} where {T, O, E}"><code>ErrorTypes.and_then</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">and_then(f, ::Type{T}, x::Result{O, E})::Result{T, E}</code></pre><p>If <code>is</code> a result value, return <code>Result{T, E}(Ok(f(unwrap(x))))</code>, else return the error value. Always returns a <code>Result{T, E}</code>.</p><p><strong>WARNING</strong> If <code>f(unwrap(x))</code> is not a <code>T</code>, this functions throws an error.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; and_then(join, String, some([&quot;ab&quot;, &quot;cd&quot;]))
some(&quot;abcd&quot;)

julia&gt; and_then(i -&gt; Int32(ncodeunits(join(i))), Int32, none(Vector{String}))
none(Int32)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/9a86cd5434a650320b5700d748826903eb6e7dac/src/ErrorTypes.jl#L487-L504">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ErrorTypes.base-Union{Tuple{Option{T}}, Tuple{T}} where T" href="#ErrorTypes.base-Union{Tuple{Option{T}}, Tuple{T}} where T"><code>ErrorTypes.base</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">base(x::Option{T})</code></pre><p>Convert an <code>Option{T}</code> to a <code>Union{Some{T}, Nothing}</code>.</p><p>See also: <a href="#Option"><code>Option</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sub_nonneg(x::Int)::Option{Int} = x &lt; 1 ? none : some(x - 1);

julia&gt; base(sub_nonneg(-3)) === nothing
true

julia&gt; base(sub_nonneg(2))
Some(1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/9a86cd5434a650320b5700d748826903eb6e7dac/src/ErrorTypes.jl#L637-L654">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ErrorTypes.expect-Tuple{Result, AbstractString}" href="#ErrorTypes.expect-Tuple{Result, AbstractString}"><code>ErrorTypes.expect</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">expect(x::Result, s::AbstractString)</code></pre><p>If <code>x</code> is of the associated error type, error with message <code>s</code>. Else, return the contained result type.</p><p>See also: <a href="#ErrorTypes.expect_error-Tuple{Result, AbstractString}"><code>expect_error</code></a>, <a href="#ErrorTypes.unwrap-Tuple{Result}"><code>unwrap</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; expect(some(&#39;x&#39;), &quot;cannot be none&quot;) === &#39;x&#39;
true

julia&gt; expect(Result{Int, String}(Ok(19)), &quot;Expected an integer&quot;)
19</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/9a86cd5434a650320b5700d748826903eb6e7dac/src/ErrorTypes.jl#L445-L461">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ErrorTypes.expect_error-Tuple{Result, AbstractString}" href="#ErrorTypes.expect_error-Tuple{Result, AbstractString}"><code>ErrorTypes.expect_error</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">expect_error(x::Result, s::AbstractString)</code></pre><p>If <code>x</code> contains an <code>Err</code>, return the content of the <code>Err</code>. Else, throw an error with message <code>s</code>.</p><p>See also: <a href="#ErrorTypes.unwrap_error-Tuple{Result}"><code>unwrap_error</code></a>, <a href="#ErrorTypes.expect-Tuple{Result, AbstractString}"><code>expect</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; expect_error(none(Int), &quot;expected none&quot;) === nothing
true

julia&gt; expect_error(Result{Vector, String}(Err(&quot;Mistake!&quot;)), &quot;must be error&quot;)
&quot;Mistake!&quot;

julia&gt; expect_error(some(3), &quot;must be none&quot;)
ERROR: must be none
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/9a86cd5434a650320b5700d748826903eb6e7dac/src/ErrorTypes.jl#L464-L484">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ErrorTypes.flatten-Union{Tuple{Result{Option{T}, Nothing}}, Tuple{T}} where T" href="#ErrorTypes.flatten-Union{Tuple{Result{Option{T}, Nothing}}, Tuple{T}} where T"><code>ErrorTypes.flatten</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">flatten(x::Option{Option{T}})</code></pre><p>Convert an <code>Option{Option{T}}</code> to an <code>Option{T}</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; flatten(some(some(&quot;x&quot;)))
some(&quot;x&quot;)

julia&gt; flatten(some(none(Float32)))
none(Float32)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/9a86cd5434a650320b5700d748826903eb6e7dac/src/ErrorTypes.jl#L621-L634">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ErrorTypes.is_error-Tuple{Result}" href="#ErrorTypes.is_error-Tuple{Result}"><code>ErrorTypes.is_error</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_error(x::Result)</code></pre><p>Check if <code>x</code> contains an error value.</p><p>See also: <a href="#ErrorTypes.Result"><code>Result</code></a>, <a href="#Option"><code>Option</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; is_error(none(Int)), is_error(some(5))
(true, false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/9a86cd5434a650320b5700d748826903eb6e7dac/src/ErrorTypes.jl#L183-L195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ErrorTypes.is_ok_and-Tuple{Any, Result}" href="#ErrorTypes.is_ok_and-Tuple{Any, Result}"><code>ErrorTypes.is_ok_and</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_ok_and(f, x::Result)::Bool</code></pre><p>Check if <code>x</code> is a result value, and <code>f(unwrap(x))</code>. <code>f(unwrap(x))</code> must return a <code>Bool</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; is_ok_and(isodd, none(Int))
false

julia&gt; is_ok_and(isodd, some(2))
false

julia&gt; is_ok_and(isodd, Result{Int, String}(Ok(9)))
true

julia&gt; is_ok_and(ncodeunits, some(&quot;Success!&quot;))
ERROR: TypeError: non-boolean (Int64) used in boolean context</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/9a86cd5434a650320b5700d748826903eb6e7dac/src/ErrorTypes.jl#L317-L337">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ErrorTypes.iter-Tuple{Option}" href="#ErrorTypes.iter-Tuple{Option}"><code>ErrorTypes.iter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iter(x::Option)::OptionIterator</code></pre><p>Produce an iterator over <code>x</code>, which yields the result value of <code>x</code> if <code>x</code> is some, or an empty iterator if it is none.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; first(iter(some(19)))
19

julia&gt; collect(iter(some(&quot;some string&quot;)))
1-element Vector{String}:
 &quot;some string&quot;

julia&gt; isempty(iter(none(Dict)))
true

julia&gt; collect(iter(none(Char)))
Char[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/9a86cd5434a650320b5700d748826903eb6e7dac/src/ErrorTypes.jl#L657-L678">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ErrorTypes.map_or-Union{Tuple{E}, Tuple{O}, Tuple{Any, Result{O, E}, Any}} where {O, E}" href="#ErrorTypes.map_or-Union{Tuple{E}, Tuple{O}, Tuple{Any, Result{O, E}, Any}} where {O, E}"><code>ErrorTypes.map_or</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_or(f, x::Result, v)</code></pre><p>If <code>x</code> is a result value, return <code>f(unwrap(x))</code>. Else, return <code>v</code>.</p><p>See also: <a href="#ErrorTypes.unwrap_or-Tuple{Result, Any}"><code>unwrap_or</code></a>, <a href="#ErrorTypes.and_then-Union{Tuple{E}, Tuple{O}, Tuple{T}, Tuple{Any, Type{T}, Result{O, E}}} where {T, O, E}"><code>and_then</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; map_or(isodd, some(9), nothing)
true

julia&gt; map_or(isodd, none(Int), nothing) === nothing
true

julia&gt; map_or(ncodeunits, none(String), 0)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/9a86cd5434a650320b5700d748826903eb6e7dac/src/ErrorTypes.jl#L510-L528">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ErrorTypes.ok-Union{Tuple{Result{T, E}}, Tuple{E}, Tuple{T}} where {T, E}" href="#ErrorTypes.ok-Union{Tuple{Result{T, E}}, Tuple{E}, Tuple{T}} where {T, E}"><code>ErrorTypes.ok</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ok(x::Result{T})::Option{T}</code></pre><p>Construct an <code>Option</code> from a <code>Result</code>, such that the <code>Ok</code> variant becomes a <code>some</code>, and the <code>Err</code> variant becomes a <code>none(T)</code>, discarding the error value if present.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ok(Result{Int32, String}(Err(&quot;Some error message&quot;)))
none(Int32)

julia&gt; ok(Result{String, Dict}(Ok(&quot;Success!&quot;)))
some(&quot;Success!&quot;)

julia&gt; ok(some(5))
some(5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/9a86cd5434a650320b5700d748826903eb6e7dac/src/ErrorTypes.jl#L294-L311">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ErrorTypes.unwrap-Tuple{Result}" href="#ErrorTypes.unwrap-Tuple{Result}"><code>ErrorTypes.unwrap</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unwrap(x::Result)</code></pre><p>If <code>x</code> is of the associated error type, throw an error. Else, return the contained result type.</p><p>See also: <a href="#ErrorTypes.unwrap_error-Tuple{Result}"><code>unwrap_error</code></a>, <a href="#ErrorTypes.@unwrap_or-Tuple{Any, Any}"><code>@unwrap_or</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unwrap(some(Any[]))
Any[]

julia&gt; unwrap(none(Int))
ERROR: unwrap on unexpected type
[...]

julia&gt; unwrap(Result{String, Int32}(Ok(&quot;Lin Wei&quot;)))
&quot;Lin Wei&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/9a86cd5434a650320b5700d748826903eb6e7dac/src/ErrorTypes.jl#L400-L420">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ErrorTypes.unwrap_error-Tuple{Result}" href="#ErrorTypes.unwrap_error-Tuple{Result}"><code>ErrorTypes.unwrap_error</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unwrap_error(x::Result)</code></pre><p>If <code>x</code> contains an <code>Err</code>, return the content of the <code>Err</code>. Else, throw an error.</p><p>See also: <a href="#ErrorTypes.unwrap-Tuple{Result}"><code>unwrap</code></a>, <a href="#ErrorTypes.expect_error-Tuple{Result, AbstractString}"><code>expect_error</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unwrap_error(some(3))
ERROR: unwrap on unexpected type
[...]

julia&gt; unwrap_error(none(String)) === nothing
true

julia&gt; unwrap_error(Result{Int, String}(Err(&quot;some error&quot;)))
&quot;some error&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/9a86cd5434a650320b5700d748826903eb6e7dac/src/ErrorTypes.jl#L423-L442">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ErrorTypes.unwrap_error_or-Tuple{Result, Any}" href="#ErrorTypes.unwrap_error_or-Tuple{Result, Any}"><code>ErrorTypes.unwrap_error_or</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unwrap_error_or(x::Result, v)</code></pre><p>Like <code>unwrap_or</code>, but unwraps an error.</p><p>See also: <a href="#ErrorTypes.unwrap_or-Tuple{Result, Any}"><code>unwrap_or</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unwrap_error_or(Result{Int, String}(Err(&quot;abc&quot;)), 19)
&quot;abc&quot;

julia&gt; unwrap_error_or(none(String), &quot;error&quot;) === nothing
true

julia&gt; unwrap_error_or(some([1, 2, 3]), Int32[])
Int32[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/9a86cd5434a650320b5700d748826903eb6e7dac/src/ErrorTypes.jl#L576-L594">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ErrorTypes.unwrap_error_or_else-Tuple{Any, Result}" href="#ErrorTypes.unwrap_error_or_else-Tuple{Any, Result}"><code>ErrorTypes.unwrap_error_or_else</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unwrap_error_or(f, x::Result</code></pre><p>Returns the wrapped error value if <code>x</code> is an error, else return <code>f(unwrap(x))</code>.</p><p>See also: <a href="#ErrorTypes.@unwrap_error_or-Tuple{Any, Any}"><code>@unwrap_error_or</code></a>, <a href="#ErrorTypes.unwrap_or_else-Tuple{Any, Result}"><code>unwrap_or_else</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unwrap_error_or_else(ncodeunits, some(&quot;abc&quot;))
3

julia&gt; unwrap_error_or_else(ncodeunits, none(String)) === nothing
true

julia&gt; unwrap_error_or_else(n -&gt; n + 1, Result{Int, String}(Err(&quot;abc&quot;)))
&quot;abc&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/9a86cd5434a650320b5700d748826903eb6e7dac/src/ErrorTypes.jl#L597-L615">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ErrorTypes.unwrap_or-Tuple{Result, Any}" href="#ErrorTypes.unwrap_or-Tuple{Result, Any}"><code>ErrorTypes.unwrap_or</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unwrap_or(x::Result, v)</code></pre><p>If <code>x</code> is an error value, return <code>v</code>. Else, unwrap <code>x</code> and return its content.</p><p>See also: <a href="#ErrorTypes.unwrap-Tuple{Result}"><code>unwrap</code></a>, <a href="#ErrorTypes.@unwrap_or-Tuple{Any, Any}"><code>@unwrap_or</code></a></p><p><strong>Examples:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unwrap_or(some(5), 9)
5

julia&gt; unwrap_or(none(Float32), &quot;something else&quot;)
&quot;something else&quot;

julia&gt; unwrap_or(Result{Int8, Vector}(Err([])), 0x01)
0x01</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/9a86cd5434a650320b5700d748826903eb6e7dac/src/ErrorTypes.jl#L531-L549">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ErrorTypes.unwrap_or_else-Tuple{Any, Result}" href="#ErrorTypes.unwrap_or_else-Tuple{Any, Result}"><code>ErrorTypes.unwrap_or_else</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unwrap_or_else(f, x::Result)</code></pre><p>If <code>x</code> is an error value, return <code>f(unwrap_error(x))</code>. Else, unwrap <code>x</code> and return its content.</p><p>See also: <a href="#ErrorTypes.unwrap_error_or_else-Tuple{Any, Result}"><code>unwrap_error_or_else</code></a>, <a href="#ErrorTypes.unwrap_or-Tuple{Result, Any}"><code>unwrap_or</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unwrap_or_else(isnothing, some(3))
3

julia&gt; unwrap_or_else(println, none(Int))
nothing

julia&gt; unwrap_or_else(ncodeunits, Result{Int, String}(Err(&quot;my_error&quot;)))
8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/9a86cd5434a650320b5700d748826903eb6e7dac/src/ErrorTypes.jl#L552-L570">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ErrorTypes.@?-Tuple{Any}" href="#ErrorTypes.@?-Tuple{Any}"><code>ErrorTypes.@?</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@?(expr)</code></pre><p>Propagate a <code>Result</code> with <code>Err</code> value to the outer function.</p><p>Evaluate <code>expr</code>, which should return a <code>Result</code>. If it contains an <code>Ok</code> value <code>x</code>, evaluate to the unwrapped value <code>x</code>. Else, evaluates to <code>return Err(x)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; (f(x::Option{T})::Option{T}) where T = Ok(@?(x) + one(T));

julia&gt; f(some(1.0)), f(none(Int))
(some(2.0), none(Int64))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/9a86cd5434a650320b5700d748826903eb6e7dac/src/ErrorTypes.jl#L269-L284">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ErrorTypes.@unwrap_error_or-Tuple{Any, Any}" href="#ErrorTypes.@unwrap_error_or-Tuple{Any, Any}"><code>ErrorTypes.@unwrap_error_or</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@unwrap_error_or(expr, exec)</code></pre><p>Evaluate <code>expr</code> to a <code>Result</code>. If <code>expr</code> is a result value, evaluate <code>exec</code> and return that. Else, return the wrapped error value in <code>expr</code>.</p><p>See also: <a href="#ErrorTypes.@unwrap_or-Tuple{Any, Any}"><code>@unwrap_or</code></a> ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/9a86cd5434a650320b5700d748826903eb6e7dac/src/ErrorTypes.jl#L385-L393">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ErrorTypes.@unwrap_or-Tuple{Any, Any}" href="#ErrorTypes.@unwrap_or-Tuple{Any, Any}"><code>ErrorTypes.@unwrap_or</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@unwrap_or(expr, exec)</code></pre><p>Evaluate <code>expr</code> to a <code>Result</code>. If <code>expr</code> is a error value, evaluate <code>exec</code> and return that. Else, return the wrapped value in <code>expr</code>.</p><p>See also: <a href="#ErrorTypes.@unwrap_error_or-Tuple{Any, Any}"><code>@unwrap_error_or</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; safe_inv(x)::Option{Float64} = iszero(x) ? none : Ok(1/x);

julia&gt; function skip_inv_sum(it)
    sum = 0.0
    for i in it
        sum += @unwrap_or safe_inv(i) continue
    end
    sum
end;

julia&gt; skip_inv_sum([2,1,0,1,2])
3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/9a86cd5434a650320b5700d748826903eb6e7dac/src/ErrorTypes.jl#L357-L380">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../motivation/">Why use ErrorTypes? »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Friday 23 May 2025 09:34">Friday 23 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
