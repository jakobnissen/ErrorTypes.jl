<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Usage · ErrorTypes.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ErrorTypes.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Usage</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Reference"><span>Reference</span></a></li></ul></li><li><a class="tocitem" href="../motivation/">Why use ErrorTypes?</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Usage</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Usage</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/master/docs/src/usage.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h1><h3 id="Types-and-how-to-construct-them"><a class="docs-heading-anchor" href="#Types-and-how-to-construct-them">Types and how to construct them</a><a id="Types-and-how-to-construct-them-1"></a><a class="docs-heading-anchor-permalink" href="#Types-and-how-to-construct-them" title="Permalink"></a></h3><p><strong>Option{T}</strong> encodes either the presence of a <code>T</code> or the absence of one. You should use this type to encode either the successful creation of <code>T</code>, or a failure that does not need any information to explain itself. Like its sibling <code>Result</code>, <code>Option</code> is a sum type from the pacage SumTypes.</p><p>An <code>Option</code> contains two <em>variants</em>, <code>None</code> and <code>Thing</code>. Like other sum types, you should usually not construct an <code>Option</code> directly. Instead, the constructors for the types <code>None</code> and <code>Thing</code> creates an <code>Option</code> wrapping them. Similarly, you should not construct a <code>None</code> or <code>Thing</code> directly - these types are only useful as the content of an <code>Option</code>.</p><ul><li>You should construct an <code>Option{T}</code> wrapping a <code>Thing</code> with <code>Thing(::T)</code>.</li><li>You <em>can</em> construct an <code>Option{T}</code> warpping a <code>None</code> object with <code>ErrorTypes.None{Int}()</code>. Normally, however, you should use the object <code>none</code> (singleton of <code>None{Nothing}</code>) and convert it to an <code>Option{T}</code>. See how in the section &quot;Basic usage&quot;.</li></ul><p><strong>Result{O, E}</strong> has the two variants <code>Ok</code>, representing the successful creation of an <code>O</code>, or else an <code>E</code>, representing some object carrying information about the error. You should use <code>Result</code> instead of <code>Option</code> when the error needs to be explained.</p><ul><li>You <em>can</em> construct <code>Result</code> objects by <code>Ok{O, E}(::O)</code> or <code>Err{O, E}(::Err)</code>. However, normally, you can instead use the simpler constructors <code>Ok(::O)</code> and <code>Err(::E)</code>. These constructors creates <code>ResultConstructor</code> objects, which can be converted to the correct <code>Result</code> types.</li></ul><h3 id="Basic-usage"><a class="docs-heading-anchor" href="#Basic-usage">Basic usage</a><a id="Basic-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-usage" title="Permalink"></a></h3><p>Always typeassert any function that returns an error type. The whole point of ErrorTypes is to encode error states in return types, and be specific about these error states. While ErrorTypes will <em>technically</em> work fine without function annotation, I highly recommend annotating return types:</p><p>Yes (note <code>none</code> is automatically converted):</p><pre><code class="language-none">invert(x::Integer)::Option{Float64} = iszero(x) ? none : Thing(1/x)</code></pre><p>No:</p><pre><code class="language-none">invert(x::Integer) = iszero(x) ? ErrorTypes.None{Float64}() : Thing(1/x)</code></pre><p>Also, by annotating return functions, you can use the simpler constructors of error types:</p><ul><li>You can use <code>none</code>, which is automatically converted to <code>Option</code> containing a <code>None</code>.</li><li>You can use <code>Err(x)</code> and <code>Ok(x)</code> to create <code>ResultConstructor</code>s, which are converted by the typeassert to the correct <code>Result</code>.</li></ul><h3 id="Conversion"><a class="docs-heading-anchor" href="#Conversion">Conversion</a><a id="Conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion" title="Permalink"></a></h3><p>Apart from the two special cases above: The conversion of <code>none</code> (of type <code>None</code>) to <code>Option</code>, and <code>Err(x)</code> and <code>Ok(x)</code> (of type <code>ResultConstructor</code>) to <code>Result</code>, error types can only convert to each other in certain circumstances. This is intentional, because type conversions is a major source of mistakes.</p><ul><li>An object of type <code>Option</code> and <code>Result</code> can be converted to its own type.</li><li>An <code>Option{T}</code> containing a <code>Thing</code> can be converted to an <code>Option{T2}</code>, if <code>T &lt;: T2</code>. You intentionally cannot convert e.g. an <code>Option{Int}</code> to an <code>Option{UInt}</code>.</li><li>A <code>Result{O, E}</code> can be converted to a <code>Result{O2, E2}</code> if <code>O &lt;: O2</code> and <code>E &lt;: E2</code>.</li></ul><p>It is intentionally NOT possible to e.g. convert a <code>Result{Int, String}</code> containing an <code>Ok</code> to a <code>Result{Int, Int}</code>, even if the <code>Ok</code> value contains an <code>Int</code> which is allowed in both of the <code>Result</code> types. The reason for this is that if it was allowed, whether or not conversions threw errors would depend on the <em>value</em> of an error type, not the type. The idea behind this package is to present edge cases as types, not values.</p><h3 id="@?"><a class="docs-heading-anchor" href="#@?">@?</a><a id="@?-1"></a><a class="docs-heading-anchor-permalink" href="#@?" title="Permalink"></a></h3><p>If you make an entire codebase of functions returning <code>Result</code>s and <code>Option</code>s, it can get bothersome to constantly check if function calls contain error values and propagate those error values. To make this process easier, use the macro <code>@?</code>, which automatically propagates any error values. If this is applied to some expression <code>x</code> evaluating to a <code>Result</code> or <code>Option</code> containing an error value, the macro will evaluate to something equivalent to <code>return Err(unwrap_err(x))</code> or <code>return none</code>, respectively. If it contains a result value, the macro is evaluated to the equivalent of <code>unwrap(x)</code>.</p><p>For example, suppose you want to implement a safe version of the harmonic mean function, which in turn uses a safe version of <code>div</code>:</p><pre><code class="language-julia">safe_div(a::Integer, b::Float64)::Option{Float64} = iszero(b) ? none : Thing(a/b)

function harmonic_mean(v::AbstractArray{&lt;:Integer})::Option{Float64}
    sm = 0.0
    for i in v
        invi = safe_div(1, i)
        is_none(invi) &amp;&amp; return none
        sm += unwrap(invi)
    end
    res = safe_div(length(v), sm)
    is_none(res) &amp;&amp; return none
    return Thing(unwrap(res))
end</code></pre><p>In this function, we constantly have to check whether <code>safe_div</code> returned the error value, and return that from the outer function in that case. That can be more concisely written as:</p><pre><code class="language-julia">function harmonic_mean(v::AbstractArray{&lt;:Integer})::Option{Float64}
    sm = 0.0
    for i in v
        sm += @? safe_div(1, i)
    end
    Thing(@? safe_div(length(v), sm))
end</code></pre><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="ErrorTypes.Err-Tuple{Any}" href="#ErrorTypes.Err-Tuple{Any}"><code>ErrorTypes.Err</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Err</code></pre><p>The error state of a <code>Result{O, E}</code>, carrying an object of type <code>E</code>. For convenience, <code>Err(x)</code> creates a dummy value that can be converted to the appropriate <code>Result type</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/0b35ad4990c724977e21f4c05fe074da8e4f0d40/src/ErrorTypes.jl#LL143-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ErrorTypes.None" href="#ErrorTypes.None"><code>ErrorTypes.None</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">None{T}</code></pre><p>The variant of <code>Option</code> signifying absence of a value of type <code>T</code>. The singleton <code>none</code> is the instance of <code>None{Nothing}</code> (NOT an <code>Option</code>), and can be freely converted to any <code>Option</code> value containing a <code>None</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/0b35ad4990c724977e21f4c05fe074da8e4f0d40/src/ErrorTypes.jl#LL176-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ErrorTypes.Ok-Tuple{Any}" href="#ErrorTypes.Ok-Tuple{Any}"><code>ErrorTypes.Ok</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Ok</code></pre><p>The success state of a <code>Result{O, E}</code>, carrying an object of type <code>O</code>. For convenience, <code>Ok(x)</code> creates a dummy value that can be converted to the appropriate <code>Result type</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/0b35ad4990c724977e21f4c05fe074da8e4f0d40/src/ErrorTypes.jl#LL134-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ErrorTypes.Option" href="#ErrorTypes.Option"><code>ErrorTypes.Option</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Option{T}</code></pre><p>A sum type of either <code>Thing{T}</code> or <code>None</code>. Used instead of <code>Result</code> as return value of functions whose error state need not carry any information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/0b35ad4990c724977e21f4c05fe074da8e4f0d40/src/ErrorTypes.jl#LL31-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ErrorTypes.Result" href="#ErrorTypes.Result"><code>ErrorTypes.Result</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Result{O, E}</code></pre><p>A sum type of either <code>Ok{O}</code> or <code>Err{E}</code>. Used as return value of functions that can error with an informative error object of type <code>E</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/0b35ad4990c724977e21f4c05fe074da8e4f0d40/src/ErrorTypes.jl#LL18-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ErrorTypes.Thing-Tuple{T} where T" href="#ErrorTypes.Thing-Tuple{T} where T"><code>ErrorTypes.Thing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Thing(x::T)</code></pre><p>Construct a <code>Thing{T}(x)</code>, variant of <code>Option</code> signifying the presence of a value <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/0b35ad4990c724977e21f4c05fe074da8e4f0d40/src/ErrorTypes.jl#LL199-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ErrorTypes.and_then-Tuple{Any,Option}" href="#ErrorTypes.and_then-Tuple{Any,Option}"><code>ErrorTypes.and_then</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">and_then(f, x::Union{Option, Result})</code></pre><p>If <code>x</code> is an error value, return <code>x</code>. Else, apply <code>f</code> to the contained value and return it wrapped as the same type as <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/0b35ad4990c724977e21f4c05fe074da8e4f0d40/src/ErrorTypes.jl#LL284-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ErrorTypes.expect" href="#ErrorTypes.expect"><code>ErrorTypes.expect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expect(x::Union{Result, Option}, s::AbstractString)</code></pre><p>If <code>x</code> is of the associated error type, error with message <code>s</code>. Else, return the contained result type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/0b35ad4990c724977e21f4c05fe074da8e4f0d40/src/ErrorTypes.jl#LL210-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ErrorTypes.expect_err-Tuple{Result,AbstractString}" href="#ErrorTypes.expect_err-Tuple{Result,AbstractString}"><code>ErrorTypes.expect_err</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">expect_err(x::Result, s::AbstractString)</code></pre><p>If <code>x</code> contains an <code>Err</code>, return the content of the <code>Err</code>. Else, throw an error with message <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/0b35ad4990c724977e21f4c05fe074da8e4f0d40/src/ErrorTypes.jl#LL235-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ErrorTypes.expect_none-Tuple{Option,AbstractString}" href="#ErrorTypes.expect_none-Tuple{Option,AbstractString}"><code>ErrorTypes.expect_none</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">expect_none(x::Option, s::AbstractString)</code></pre><p>If <code>x</code> contains a <code>None</code>, return <code>nothing</code>. Else, throw an error with message <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/0b35ad4990c724977e21f4c05fe074da8e4f0d40/src/ErrorTypes.jl#LL228-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ErrorTypes.flatten-Union{Tuple{Option{Option{T}}}, Tuple{T}} where T" href="#ErrorTypes.flatten-Union{Tuple{Option{Option{T}}}, Tuple{T}} where T"><code>ErrorTypes.flatten</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">flatten(x::Option{Option{T}})</code></pre><p>Convert an <code>Option{Option{T}}</code> to an <code>Option{T}</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; flatten(Thing(Thing(&quot;x&quot;)))
Option{String}: Thing(&quot;x&quot;)

julia&gt; flatten(Thing(None{Int}()))
Option{Int64}: None()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/0b35ad4990c724977e21f4c05fe074da8e4f0d40/src/ErrorTypes.jl#LL320-L334">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ErrorTypes.unwrap" href="#ErrorTypes.unwrap"><code>ErrorTypes.unwrap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">unwrap(x::Union{Result, Option})</code></pre><p>If <code>x</code> is of the associated error type, throw an error. Else, return the contained result type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/0b35ad4990c724977e21f4c05fe074da8e4f0d40/src/ErrorTypes.jl#LL248-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ErrorTypes.unwrap_err-Tuple{Result}" href="#ErrorTypes.unwrap_err-Tuple{Result}"><code>ErrorTypes.unwrap_err</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unwrap_err(x::Result)</code></pre><p>If <code>x</code> contains an <code>Err</code>, return the content of the <code>Err</code>. Else, throw an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/0b35ad4990c724977e21f4c05fe074da8e4f0d40/src/ErrorTypes.jl#LL273-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ErrorTypes.unwrap_none-Tuple{Option}" href="#ErrorTypes.unwrap_none-Tuple{Option}"><code>ErrorTypes.unwrap_none</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unwrap_none(x::Option)</code></pre><p>If <code>x</code> contains a <code>None</code>, return <code>nothing</code>. Else, throw an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/0b35ad4990c724977e21f4c05fe074da8e4f0d40/src/ErrorTypes.jl#LL266-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ErrorTypes.unwrap_or-Tuple{Option,Any}" href="#ErrorTypes.unwrap_or-Tuple{Option,Any}"><code>ErrorTypes.unwrap_or</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unwrap_or(x::Union{Option, Result}, v)</code></pre><p>If <code>x</code> is an error value, return <code>v</code>. Else, unwrap <code>x</code> and return its content.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/0b35ad4990c724977e21f4c05fe074da8e4f0d40/src/ErrorTypes.jl#LL305-L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ErrorTypes.@?-Tuple{Any}" href="#ErrorTypes.@?-Tuple{Any}"><code>ErrorTypes.@?</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@?(expr)</code></pre><p>Propagate a <code>Result</code> or <code>Option</code> error value to the outer function. Evaluate <code>expr</code>, which should return a <code>Result</code> or <code>Option</code>. If it contains a result value <code>x</code>, evaluate to the unwrapped value <code>x</code>. Else, evaluates to <code>return none</code> for <code>Option</code> and <code>return Err(x)</code> for Result.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; (f(x::Option{T})::Option{T}) where T = Thing(@?(x) + one(T))

julia&gt; f(Thing(1.0)), f(None{Int}())
(Option{Float64}: Thing(2.0), Option{Int64}: None())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/0b35ad4990c724977e21f4c05fe074da8e4f0d40/src/ErrorTypes.jl#LL39-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ErrorTypes.@unwrap_or-Tuple{Any,Any}" href="#ErrorTypes.@unwrap_or-Tuple{Any,Any}"><code>ErrorTypes.@unwrap_or</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@unwrap_or(expr, exec)</code></pre><p>Evaluate <code>expr</code> to a <code>Result</code> or <code>Option</code>. If <code>expr</code> is a error value, evaluate <code>exec</code> and return that. Else, return the wrapped value in <code>expr</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; safe_inv(x)::Option{Float64} = iszero(x) ? none : Thing(1/x);

julia&gt; function skip_inv_sum(it)
    sum = 0.0
    for i in it
        sum += @unwrap_or safe_inv(i) continue
    end
    sum
end;

julia&gt; skip_inv_sum([2,1,0,1,2])
3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/0b35ad4990c724977e21f4c05fe074da8e4f0d40/src/ErrorTypes.jl#LL80-L102">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../motivation/">Why use ErrorTypes? »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 10 February 2021 10:55">Wednesday 10 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
