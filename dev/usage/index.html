<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Usage · ErrorTypes.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ErrorTypes.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Usage</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Reference"><span>Reference</span></a></li></ul></li><li><a class="tocitem" href="../motivation/">Why use ErrorTypes?</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Usage</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Usage</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/master/docs/src/usage.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h1><h3 id="The-Option-and-Result-type."><a class="docs-heading-anchor" href="#The-Option-and-Result-type.">The Option and Result type.</a><a id="The-Option-and-Result-type.-1"></a><a class="docs-heading-anchor-permalink" href="#The-Option-and-Result-type." title="Permalink"></a></h3><p><code>Err{E}</code> and <code>Some{T}</code> are simple wrapper structs with little functionality in themselves. <code>Some</code> is from Base Julia, <code>Err</code> from this package. They are only used to wrap a value to represent a correctly generated result (<code>Some</code>) or an error (<code>Err</code>). They are two distinct types, such that a correctly-produced value of type T can be distinguished from an error of type T (e.g. an integer result from an integer error code).</p><p><code>Result{T, E}</code> is merely an alias for <code>Union{Some{T}, Err{E}}</code>. Thus, the result of a failable funtion that can give a result of type T or an error of type E is a <code>Result{T, E}</code>. Do remember Julia&#39;s parametric invariance: It is NOT true that <code>Some([1]) isa Result{Vector, String}</code>, whereas it IS true that it is a <code>Result{&lt;:Vector, String}</code>.</p><p>In many cases, the error type does not need to be specified because there is only one relevant error condition. In these situations, it&#39;s easier to use <code>Option{T}</code>. This is simply an alias of <code>Union{Some{T}, Nothing}</code>.</p><h3 id="Basic-usage"><a class="docs-heading-anchor" href="#Basic-usage">Basic usage</a><a id="Basic-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-usage" title="Permalink"></a></h3><p>Always typeassert any function that returns an error type. The whole point of ErrorTypes is to encode error states in return types, and be specific about these error states. While ErrorTypes will <em>technically</em> work fine without function annotations, I highly recommend annotating return types:</p><p>Do this:</p><pre><code class="language-none">invert(x::Integer)::Option{Float64} = iszero(x) ? nothing : Some(1/x)</code></pre><p>And not this:</p><pre><code class="language-none">invert(x::Integer) = iszero(x) ? nothing : Some(1/x)</code></pre><p>The typeassert will cause your functions to fail immediately in testing, and will also be caught by static type checkers such as JET.jl. Note that typeasserts applied to functions are different than other typeasserts, which will not be caught by JET.jl.</p><h3 id="Convenience-functions"><a class="docs-heading-anchor" href="#Convenience-functions">Convenience functions</a><a id="Convenience-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Convenience-functions" title="Permalink"></a></h3><p>The entire point of this package is static types made convenient. Since unions are already part of Base Julia, the idea of this package is to provide convenience functions. Particularly useful functions are <code>something_or</code>, <code>and_then</code>, and <code>flatten</code>.</p><h3 id="Conversion"><a class="docs-heading-anchor" href="#Conversion">Conversion</a><a id="Conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion" title="Permalink"></a></h3><p>Converting to and from <code>Err</code> is intentionally limited to prevent silent errors. Only two kinds of conversions are possible:</p><ul><li>Converting an <code>Err</code> to <code>Option</code>, which results in <code>nothing</code>, and</li><li>Converting an <code>Err{E1}</code> to an <code>Err{&gt;:E1}</code>, which simply re-wraps the input value.</li></ul><h3 id="@?"><a class="docs-heading-anchor" href="#@?">@?</a><a id="@?-1"></a><a class="docs-heading-anchor-permalink" href="#@?" title="Permalink"></a></h3><p>If you make an entire codebase of functions returning <code>Result</code>s, it can get bothersome to constantly check if function calls contain error values and propagate those error values. To make this process easier, use the macro <code>@?</code>, which automatically propagates any error values. If this is applied to some expression <code>x</code> evaluating to a <code>Result</code> or <code>Option</code> containing an error value, the macro will evaluate to <code>return x</code>. If it contains a result value, the macro is evaluated to <code>something(x)</code>.</p><p>For example, suppose you want to implement a safe version of the harmonic mean function, which in turn uses a safe version of <code>div</code>:</p><pre><code class="language-julia">safe_div(a::Integer, b::Real)::Option{Float64} = iszero(b) ? nothing : Some(a/b)

function harmonic_mean(v::AbstractArray{&lt;:Integer})::Option{Float64}
    sm = 0.0
    for i in v
        invi = safe_div(1, i)
        isnothing(invi) &amp;&amp; return nothing
        sm += something(invi)
    end
    return safe_div(length(v), sm)
end</code></pre><p>In this function, we constantly have to check whether <code>safe_div</code> returned the error value, and return that from the outer function in that case. That can be more concisely written as:</p><pre><code class="language-julia">function harmonic_mean(v::AbstractArray{&lt;:Integer})::Option{Float64}
    sm = 0.0
    for i in v
        sm += @? safe_div(1, i)
    end
    return safe_div(length(v), sm)
end</code></pre><h3 id="When-to-use-an-error-type-vs-throw-an-error"><a class="docs-heading-anchor" href="#When-to-use-an-error-type-vs-throw-an-error">When to use an error type vs throw an error</a><a id="When-to-use-an-error-type-vs-throw-an-error-1"></a><a class="docs-heading-anchor-permalink" href="#When-to-use-an-error-type-vs-throw-an-error" title="Permalink"></a></h3><p>The error handling mechanism provided by ErrorTypes is a distinct method from throwing and catching errors. None is superior to the other in all circumstances.</p><p>The handling provided by ErrorTypes is faster, safer, and more explicit. For <em>most</em> functions, you can use ErrorTypes. However, you can&#39;t <em>only</em> rely on it. Imagine a function <code>A</code> returning <code>Option{T1}</code>. <code>A</code> is called from function <code>B</code>, which can itself fail and returns an <code>Option{T2}</code>. However, now there are two distinct error states: Failure in <code>A</code> and failure in <code>B</code>. So what should <code>B</code> return? <code>Result{T2, Enum{E1, E2}}</code>, for some <code>Enum</code> type? But then, what about functions calling <code>B</code>? Where does it end?</p><p>In general, it&#39;s un-idiomatic to &quot;accumulate&quot; error states like this. You should handle an error state when it appears, and usually not return it far back the call chain.</p><p>More importantly, you should distinguish between <em>recoverable</em> and <em>unrecoverable</em> error states. The unrecoverable are unexpected, and reveals that the program went wrong somehow. If the program went somewhere it shouldn&#39;t be, it&#39;s best to abort the program and show the stack trace, so you can debug it - here, an ordinary exception is better. If the errors are known to be possible beforehand, using ErrorTypes is better. For example, a program may use exceptions when encountering errors when parsing &quot;internal&quot; machine-generated files, which are <em>supposed</em> to be of a certain format, and use error types when parsing user input, which must always be expected to be possibly fallible.</p><p>Because error types are so easily converted to exceptions (using <code>unwrap</code> and <code>expect</code>), internal library functions should preferably use error types.</p><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="ErrorTypes.Option" href="#ErrorTypes.Option"><code>ErrorTypes.Option</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Option{T}</code></pre><p>Alias for <code>Union{Some{T}, Nothing}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/582795ff7056378c938da2bc56ada5e712ad219a/src/ErrorTypes.jl#LL19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ErrorTypes.Result" href="#ErrorTypes.Result"><code>ErrorTypes.Result</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Result{T, E}</code></pre><p>Alias for <code>Union{Some{T}, Err{E}}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/582795ff7056378c938da2bc56ada5e712ad219a/src/ErrorTypes.jl#LL12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ErrorTypes.Err" href="#ErrorTypes.Err"><code>ErrorTypes.Err</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Err{E}</code></pre><p>Wrapper type for error results of type <code>E</code>. Used in Union{Some{T}, Err{E}}.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/582795ff7056378c938da2bc56ada5e712ad219a/src/ErrorTypes.jl#LL3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ErrorTypes.and_then-Union{Tuple{T}, Tuple{Any, Type{T}, Union{Union{Nothing, Some{T}} where T, Result{T, E} where {T, E}}}} where T" href="#ErrorTypes.and_then-Union{Tuple{T}, Tuple{Any, Type{T}, Union{Union{Nothing, Some{T}} where T, Result{T, E} where {T, E}}}} where T"><code>ErrorTypes.and_then</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">and_then(f, ::Type{T}, x::Union{Option{T}, Result{T}})</code></pre><p>If <code>x</code> is something, return <code>Some(f(something(x)))::T</code>, else return <code>x</code>.</p><p><strong>WARNING</strong> If <code>f(something(x))</code> is not a <code>T</code>, this functions throws an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/582795ff7056378c938da2bc56ada5e712ad219a/src/ErrorTypes.jl#LL133-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ErrorTypes.expect-Tuple{Union{Union{Nothing, Some{T}} where T, Result{T, E} where {T, E}}, AbstractString}" href="#ErrorTypes.expect-Tuple{Union{Union{Nothing, Some{T}} where T, Result{T, E} where {T, E}}, AbstractString}"><code>ErrorTypes.expect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">expect(x::Union{Option, Result}, s::AbstractString)</code></pre><p>If <code>x</code> is of the associated error type, error with message <code>s</code>. Else, call <code>something</code> on the value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/582795ff7056378c938da2bc56ada5e712ad219a/src/ErrorTypes.jl#LL92-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ErrorTypes.expect_err-Union{Tuple{T}, Tuple{Union{Nothing, Some{T}, Result{T, E} where E}, AbstractString}} where T" href="#ErrorTypes.expect_err-Union{Tuple{T}, Tuple{Union{Nothing, Some{T}, Result{T, E} where E}, AbstractString}} where T"><code>ErrorTypes.expect_err</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">expect_err(x::Union{Result, Option}, s::AbstractString)</code></pre><p>If <code>x</code> is an <code>Err</code> or <code>nothing</code>, return the wrapped value. Else, throw an error with message <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/582795ff7056378c938da2bc56ada5e712ad219a/src/ErrorTypes.jl#LL109-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ErrorTypes.flatten-Union{Tuple{Union{Nothing, Some{var&quot;#s3&quot;}} where var&quot;#s3&quot;&lt;:Union{Nothing, Some{T}}}, Tuple{T}} where T" href="#ErrorTypes.flatten-Union{Tuple{Union{Nothing, Some{var&quot;#s3&quot;}} where var&quot;#s3&quot;&lt;:Union{Nothing, Some{T}}}, Tuple{T}} where T"><code>ErrorTypes.flatten</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">flatten(x::Option{Option{T}})</code></pre><p>Convert an <code>Option{Option{T}}</code> to an <code>Option{T}</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; flatten(Some(Some(&quot;x&quot;)))
Some(&quot;x&quot;)

julia&gt; flatten(Some(nothing))
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/582795ff7056378c938da2bc56ada5e712ad219a/src/ErrorTypes.jl#LL152-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ErrorTypes.something_or-Tuple{Union{Union{Nothing, Some{T}} where T, Result{T, E} where {T, E}}, Any}" href="#ErrorTypes.something_or-Tuple{Union{Union{Nothing, Some{T}} where T, Result{T, E} where {T, E}}, Any}"><code>ErrorTypes.something_or</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">something_or(x::Result, v)</code></pre><p>If <code>x</code> is an error value, return <code>v</code>. Else, unwrap <code>x</code> and return its content.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/582795ff7056378c938da2bc56ada5e712ad219a/src/ErrorTypes.jl#LL145-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ErrorTypes.unwrap-Tuple{Union{Union{Nothing, Some{T}} where T, Result{T, E} where {T, E}}}" href="#ErrorTypes.unwrap-Tuple{Union{Union{Nothing, Some{T}} where T, Result{T, E} where {T, E}}}"><code>ErrorTypes.unwrap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unwrap(x::Union{Option, Result})</code></pre><p>Like <code>expect</code>, but throws a generic <code>TypeError</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/582795ff7056378c938da2bc56ada5e712ad219a/src/ErrorTypes.jl#LL102-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ErrorTypes.unwrap_err-Tuple{Union{Union{Nothing, Some{T}} where T, Result{T, E} where {T, E}}}" href="#ErrorTypes.unwrap_err-Tuple{Union{Union{Nothing, Some{T}} where T, Result{T, E} where {T, E}}}"><code>ErrorTypes.unwrap_err</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unwrap_err(x::Union{Option, Result})</code></pre><p>Like <code>expect_err</code>, but throws a generic <code>TypeError</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/582795ff7056378c938da2bc56ada5e712ad219a/src/ErrorTypes.jl#LL126-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ErrorTypes.@?-Tuple{Any}" href="#ErrorTypes.@?-Tuple{Any}"><code>ErrorTypes.@?</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@?(expr)</code></pre><p>Propagate a <code>Result</code> or <code>Option</code> with error value to the outer function. Evaluate <code>expr</code>, which should return a <code>Union{Option, Result}</code> <code>x</code>. If x is a <code>Some</code>, evaluate to <code>something(x)</code>. Else, evaluates to <code>return x</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; (f(x::Option{T})::typeof(x)) where T = Some(@?(x) + one(T));

julia&gt; f(Some(1.0)), f(nothing)
(Some(2.0), nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/582795ff7056378c938da2bc56ada5e712ad219a/src/ErrorTypes.jl#LL36-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ErrorTypes.@something_or-Tuple{Any, Any}" href="#ErrorTypes.@something_or-Tuple{Any, Any}"><code>ErrorTypes.@something_or</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@something_or(expr, exec)</code></pre><p>Evaluate <code>expr</code> to a <code>Result</code> or <code>Option</code>. If <code>expr</code> is a error value, evaluates to <code>exec</code>. Else, evaluate <code>something(expr)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; safe_inv(x)::Option{Float64} = iszero(x) ? nothing : Some(1/x);

julia&gt; function skip_inv_sum(it)
    sum = 0.0
    for i in it
        sum += @something_or safe_inv(i) continue
    end
    sum
end;

julia&gt; skip_inv_sum([2,1,0,1,2])
3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/ErrorTypes.jl/blob/582795ff7056378c938da2bc56ada5e712ad219a/src/ErrorTypes.jl#LL61-L83">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../motivation/">Why use ErrorTypes? »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 14 June 2021 14:40">Monday 14 June 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
